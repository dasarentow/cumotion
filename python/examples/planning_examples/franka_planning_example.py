#!/usr/bin/env python3

# SPDX-FileCopyrightText: Copyright (c) 2020-2025 NVIDIA CORPORATION & AFFILIATES.
#                         All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This example demonstartes how to plan a collision free path to a target for Franka."""

# Standard Library
import os
from time import sleep

# Third Party
import numpy as np

# cuMotion
import cumotion
try:
    from cumotion_vis.visualizer import FrankaVisualization, RenderableType, Visualizer

    ENABLE_VIS = True
except ImportError:
    print("Visualizer not installed. Disabling visualization.")
    ENABLE_VIS = False

# Set cuMotion root directory
CUMOTION_ROOT_DIR = os.path.realpath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))


def cumotion_print_status(success):
    """Print the final status of the example."""
    if success:
        print("CUMOTION EXAMPLE COMPLETED SUCCESSFULLY")
    else:
        print("CUMOTION EXAMPLE FAILED")


def VisualizePath(robot_description, box_position_length_pairs, joint_positions, task_space_target):
    """Visualize the path generated by the motion plan."""
    if not ENABLE_VIS:
        return

    # Initialize visualization.
    visualizer = Visualizer()

    # Add robot arm visualization to scene.
    mesh_folder = os.path.join(CUMOTION_ROOT_DIR, 'content', 'third_party', 'franka', 'meshes')
    franka_visualization = FrankaVisualization(
        robot_description, mesh_folder, visualizer, joint_positions[0])

    # Add visualization box for obstacle box to scene.
    box_config = {'color': [0.0, 0.0, 1.0]}

    for i, pair in enumerate(box_position_length_pairs):
        box_config.update({'position': pair[0]})
        box_config.update({'side_lengths': pair[1]})
        unique_name = "box" + str(i)

        visualizer.add(RenderableType.BOX, unique_name, box_config)

    # Add orange visualization marker for end effector target position to scene.
    target_config = {
        'position': task_space_target,
        'radius': 0.05,
        'color': [1.0, 0.5, 0.0]
    }
    visualizer.add(RenderableType.MARKER, "target", target_config)

    # Visualize the path to the target, looping until the visualization window is manually closed.
    while visualizer.is_active():
        for q in joint_positions:
            if visualizer.is_active():
                franka_visualization.set_joint_positions(q)
                visualizer.update()
                sleep(0.05)
            else:
                break

    visualizer.close()


if __name__ == '__main__':
    # Set directory for planner configuration and robot description YAML files.
    config_path = os.path.join(CUMOTION_ROOT_DIR, 'content', 'nvidia', 'shared')

    # Set absolute path to planning configuration for Franka.
    planning_config_path = os.path.join(config_path, 'franka_planner_config.yaml')

    # Set absolute path to the XRDF for Franka.
    xrdf_path = os.path.join(config_path, 'franka.xrdf')

    # Set abolute path to URDF file for Franka.
    urdf_path = os.path.join(CUMOTION_ROOT_DIR, 'content', 'third_party', 'franka', 'franka.urdf')

    # Load robot description.
    robot_description = cumotion.load_robot_from_file(xrdf_path, urdf_path)

    # Create world.
    world = cumotion.create_world()

    # Add box obstacles in front of robot arm.
    # Each pair represents the center position and side lengths of a box.
    position_length_pairs = [
        (np.array([0.55, 0.0, 0.6]), np.array([0.4, 1.5, 0.02])),
        (np.array([0.35, -0.5, 0.4]), np.array([0.02, 0.5, 0.4])),
        (np.array([0.35, 0.5, 0.4]), np.array([0.02, 0.5, 0.4])),
        (np.array([0.35, 0.0, 0.1]), np.array([0.02, 1.5, 0.3]))
    ]

    for pair in position_length_pairs:
        box_obstacle_pose = cumotion.Pose3.from_translation(pair[0])
        box = cumotion.create_obstacle(cumotion.Obstacle.Type.CUBOID)
        box.set_attribute(cumotion.Obstacle.Attribute.SIDE_LENGTHS, pair[1])
        world.add_obstacle(box, box_obstacle_pose)

    # Set tool frame name.
    tool_frame_name = "panda_leftfingertip"

    # Create motion planner.
    config = cumotion.create_motion_planner_config_from_file(planning_config_path,
                                                             robot_description,
                                                             tool_frame_name,
                                                             world.add_world_view())
    planner = cumotion.create_motion_planner(config)

    # Set initial configuration.
    q0 = np.array([0.0, 0.0, 0.0, -1.0, 0.0, 1.5, 0.0])

    # Set c-space target.
    q_target = np.array([0.0, 1.0, 0.0, -1.0, 0.0, 1.5, 0.0])

    # Set task space target corresponding to c-space target.
    kinematics = robot_description.kinematics()
    end_effector_target_pose = kinematics.pose(q_target, tool_frame_name)
    translation_target = end_effector_target_pose.translation

    # Plan a path to c-space target.
    generate_interpolated_path = True
    q_results = planner.plan_to_cspace_target(q0, q_target, generate_interpolated_path)

    # Visualize path to c-space target (if found).
    if q_results.path_found:
        print("Found path with " + str(len(q_results.path)) + " knots.")
        success = len(q_results.path) == 8
        VisualizePath(
            robot_description,
            position_length_pairs,
            q_results.interpolated_path,
            translation_target)
    else:
        success = False
        print("Unable to find path.")

    # Plan a path to task space target.
    translation_results = planner.plan_to_translation_target(q0,
                                                             translation_target,
                                                             generate_interpolated_path)

    # Visualize path to task space target(if found).
    if translation_results.path_found:
        print("Found path with " + str(len(translation_results.path)) + " knots.")
        if len(translation_results.path) != 6:
            success = False
        VisualizePath(
            robot_description,
            position_length_pairs,
            translation_results.interpolated_path,
            translation_target)
    else:
        success = False
        print("Unable to find path.")

    cumotion_print_status(success)
