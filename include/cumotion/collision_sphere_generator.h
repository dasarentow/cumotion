// SPDX-FileCopyrightText: Copyright (c) 2022-2025 NVIDIA CORPORATION & AFFILIATES.
//                         All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "Eigen/Core"

namespace cumotion {

//! The `CollisionSphereGenerator` generates a set of spheres to approximate the volume enclosed by
//! a triangular mesh.
class CollisionSphereGenerator {
 public:
  virtual ~CollisionSphereGenerator() = default;

  //! Simple representation of a sphere.
  struct Sphere {
    //! 3d coordinates for the center position of the sphere.
    Eigen::Vector3d center;

    //! Radius of the sphere.
    double radius;
  };

  //! Generate a set of `num_spheres` that approximate the volume of the specified mesh.
  //!
  //! If `radius_offset` is set to zero, all of the generated spheres will be (approximately)
  //! tangent to at least two triangles in the mesh. A positive `radius_offset` will increase the
  //! radii of all spheres by adding `radius_offset` (e.g., a `radius_offset` of 0.05 will allow
  //! spheres to extend beyond the mesh by up to 0.05). A negative value will shrink the radii of
  //! the returned spheres (down to a minimum radius of `min_sphere_radius` as described in the
  //! documentation for `setParam()`).
  virtual std::vector<Sphere> generateSpheres(int num_spheres, double radius_offset) = 0;

  //! Specify the value for a given parameter.
  //!
  //! The required `ParamValue` constructor for each parameter is detailed in the documentation for
  //! `setParam()`.
  struct ParamValue {
    //! Create `ParamValue` from `int`.
    ParamValue(int value);  // NOLINT Allow implicit conversion
    //! Create `ParamValue` from `double`.
    ParamValue(double value);  // NOLINT Allow implicit conversion
    //! Create `ParamValue` from `bool`.
    ParamValue(bool value);  // NOLINT Allow implicit conversion

    struct Impl;
    std::shared_ptr<Impl> impl;
  };

  //! Set the value of the parameter.
  //!
  //! If the value has been successfully updated, `true` is returned. If an invalid value has been
  //! specified for a parameter, a verbose warning is logged, `false` is returned and the parameter
  //! value is *NOT* updated.
  //!
  //! Default parameters are expected to work well for most meshes commonly used to represent
  //! robots (i.e., generally "meter scale"). If the meshes are particularly larger or smaller
  //! (or represented in units other than meters), then `min_sphere_radius`,
  //! `convergence_radius_tol`, 'surface_offset`, `min_triangle_area`, and 'num_voxels' can be
  //! scaled appropriately.
  //!
  //! Likewise, the default parameters assume a conventional counter-clockwise winding order for
  //! vertex indices. If this is *not* the case, `flip_normals` can be set to `true`.
  //!
  //! Finally, increasing `num_medial_sphere_samples` may increase the quality of the selected
  //! spheres (at the expense of more processing time).
  //!
  //! The full set of parameters that can be set are:
  //!
  //! `num_medial_sphere_samples` [`int`]
  //!   - The collision sphere generation begins by sampling medial spheres uniformly from the
  //!     surface of the provided mesh. The medial axis of a mesh is the set of all points having
  //!     more than one closest point to the mesh. The medial spheres are spheres centered on the
  //!     medial axis with radius set to the minimum distance from the mesh. By definition, these
  //!     medial spheres are tangent to at least two faces of the mesh.
  //!   - These sampled spheres are the set from which the minimal set of spheres to approximate
  //!     the mesh will be selected. A larger number of samples may result in a better selection of
  //!     spheres, and more spheres may be valuable if the mesh is particularly complex.
  //!   - `num_medial_sphere_samples` must be positive.
  //!   - Default value is 500.
  //!
  //! `flip_normals` [`bool`]
  //!   - The mesh input to the `CollisionSphereGenerator ` is not required to be strictly
  //!     watertight, but is expected to generally represent a volume. Spheres will be generated by
  //!     sampling points on the triangular mesh faces and "growing" the spheres inwards to find a
  //!     sphere that is tangent to both the original triangle and some other triangle on the mesh.
  //!   - It is expected that for any point on any triangular face, a sphere that is tangent to that
  //!     point on the "inside" (negative normal direction) of the triangle with diameter set to the
  //!     maximum extent on the mesh will intersect at least one other triangle.
  //!   - The normal is by default computed assuming a counter-clockwise winding direction for
  //!     vertex indices. If the mesh is input with clockwise winding direction for vertex indices,
  //!     then `flip_normals` should be set to `true` to reverse winding order.
  //!   - Default value is `false`.
  //!
  //! `min_sphere_radius` [`double`]
  //!   - When generating medial spheres, any spheres that are found to have radius less than
  //!     `min_sphere_radius` will be discarded.
  //!   - NOTE: Discarded spheres still count towards `num_medial_sphere_samples`. E.g., if
  //!     `generateSpheres()` is called with `num_medial_sphere_samples` = 500, and 20 spheres are
  //!     discarded for being too small, then the actual number of spheres that will be used to
  //!     select the final spheres is 480.
  //!   - `min_sphere_radius` must be positive.
  //!   - Default value is 1e-3.
  //!
  //! `seed` [`int`]
  //!   - Random seed used for sampling surface points on mesh from which to sample spheres.
  //!   - `seed` must be positive.
  //!   - Default value is 12345.
  //!
  //! `max_iterations` [`int`]
  //!   - Maximum number of iterations of binary search used to approximate the radius of each
  //!     medial sphere.
  //!   - NOTE: If `max_iterations` is reached, the sphere will be discarded. Discarded spheres
  //!     still count towards `num_medial_sphere_samples`. E.g., if `generateSpheres()` is called
  //!     with `num_medial_sphere_samples` = 500, and 20 spheres are discarded for not converging to
  //!     the medial sphere radius tolerance within the `max_iterations`, then the actual number of
  //!     spheres that will be used to select the final spheres is 480.
  //!   - `max_iterations` must be positive.
  //!   - Default value is 100.
  //!
  //! `convergence_radius_tol` [`double`]
  //!   - Convergence criteria for binary search used to approximate the radius of each medial
  //!     sphere. The search will end when the sphere radius is within `convergence_radius_tol` of
  //!     the actual medial sphere radius.
  //!   - `convergence_radius_tol` must be positive.
  //!   - Default value is 1e-3.
  //!
  //! `surface_offset` [`double`]
  //!   - When points are sampled from the mesh surface to generate medial spheres, they are offset
  //!     by `surface_offset` towards the "inside" of the mesh in order to avoid collisions with
  //!     faces very close to the sampling face. This is to help avoid very small spheres that would
  //!     be culled due to the `min_sphere_radius`.
  //!   - `surface_offset` must be positive.
  //!   - Default value is 1e-4.
  //!
  //! `min_triangle_area` [`double`]
  //!   - Triangles with area below `min_triangle_area` are discarded when creating the mesh for
  //!     generating medial spheres. This includes degenerate triangles where surface area
  //!     approaches zero as well as relatively small triangles that will increase computation cost
  //!     without being likely to improve the set of sampled spheres.
  //!   - `min_triangle_area` must be positive.
  //!   - Default value is 1e-8.
  //!
  //!  `num_voxels` [`int`]
  //!    - A voxel grid is used to estimate volume additions from each sphere when selecting spheres
  //!      from the full sample of medial spheres. The `num_voxels` provides a trade-off between
  //!      accurate volume approximation (with larger `num_voxels`) and faster selection (with
  //!      smaller `num_voxels`).
  //!    - `num_voxels` specifies the number of voxels along the longest dimension of an
  //!      axis-aligned bounding box (AABB) encompassing the specified mesh. For example, if the
  //!      AABB has dimensions {20, 50, 30} and `num_voxels is set to 100, then each voxel will
  //!      have side length 50 / 100 = 0.5. Thus, the number of voxels along each axis of the grid
  //!      will be [40, 100, 60].
  //!    - `voxel_size` must be positive.
  //!    - Default value is 50.
  virtual bool setParam(const std::string &param_name, ParamValue value) = 0;

  //! Return the number of validated triangles that have been included in the mesh used for sampling
  //! spheres to approximate volume.
  //! NOTE: The number of returned triangles may be less than the number of `triangles` passed to
  //!       `CreateCollisionSphereGenerator()` if triangles are discarded for invalid indices or
  //!       having an area smaller than `min_triangle_area` (see `setParam()` documentation for
  //!       details).
  virtual int numTriangles() = 0;

  //! Return all of the medial axis spheres used to approximate the volume of the mesh. The spheres
  //! returned by `generateSpheres()` are selected from this set.
  //! NOTE: This function is intended primarily for debugging functionality and/or tuning parameters
  //!       in `setParam()` and is not likely to be needed by most users.
  virtual std::vector<Sphere> getSampledSpheres() = 0;
};

//! Create a `CollisionSphereGenerator` to generate spheres that approximate the volume of a mesh
//! represented by `vertices` and `triangles`.
//!
//! Each vertex in `vertices` is a set of (x,y,z) coordinates that can be referenced by one or more
//! triangles in `triangles`. Each triangle is a set of indices in the `vertices` vector.
//!
//! Vertex indices for a given triangle are considered valid if:
//!   [a] The index for each vertex is in range [0, vertices.size()), and
//!   [b] The same index is *NOT* included twice.
//!
//! Triangles with invalid indices will be discarded with verbose warnings.
//!
//! Additionally, each triangle in `triangles` is tested to ensure that its area is greater than or
//! equal to `min_triangle_radius` (see `CollisionSphereGenerator::setParam()` documentation for
//! details). Triangles that are too small will be discarded.
//!
//! By default, the triangle normals will be computed assuming a counter-clockwise winding
//! direction. This convention can be flipped by setting `flip_normals` (see
//! `CollisionSphereGenerator::setParam()` documentation for details).
std::unique_ptr<CollisionSphereGenerator>
CreateCollisionSphereGenerator(const std::vector<Eigen::Vector3d> &vertices,
                               const std::vector<Eigen::Vector3i> &triangles);

//! Default input parameters for `GenerateCollisionSpheres()`.
constexpr double kCollisionSphereDefaultMaxOvershoot = 0.05;
constexpr int kCollisionSphereDefaultMaxNumSpheres = 3000;
constexpr double kCollisionSphereDefaultSurfacePointDensity = 30000.;
constexpr int kCollisionSphereDefaultSurfacePointSamplingSeed = 123;
constexpr bool kCollisionSphereDefaultFlipNormals = false;
constexpr double kCollisionSphereDefaultMinTriangleArea = 1e-8;

//! Generate a selection of collision spheres from a grid of points filling a triangle mesh.
//!
//! NOTE: For most meshes, this `GenerateCollisionSpheres()` function is expected to perform better
//!       than `CollisionSphereGenerator()` (which is likely to be deprecated).
//!
//! The mesh is represented by `triangles` and `vertices`, where each triangle in `triangles` is a
//! set of indices referencing points in `vertices`. At least three `vertices` and at least one
//! triangle must be provided.
//!
//! The `max_overshoot` serves as an upper bound for how far any collision sphere may extend beyond
//! the surface of the mesh. The units of the `max_overshoot` are the same as the mesh, typically
//! meters for robotics applications. The `max_overshoot` must be positive.
//!
//! Larger `max_overshoot` values will create conservative collision sphere representations with
//! relatively few spheres (increasing performance for motion generation and collision checking).
//! Smaller `max_overshoot` values will fit spheres more tightly to the mesh and will (in general)
//! require more spheres to fit a given mesh (reducing performance for motion generation and
//! collision checking).
//!
//! The `max_num_spheres` sets an upper bound on the number of candidate spheres from which
//! collision spheres will be selected. Specifically, the `max_num_spheres` is used to generate a
//! grid of points filling the axis-aligned bounding box enclosing the mesh. These points serve as
//! potential sphere centers. The `max_num_spheres` may need to be increased from the default value
//! for particularly large meshes or for particularly small `max_overshoot` values. Increasing
//! `max_num_spheres` will (in general) improve the selection of collision spheres, but result in
//! slower generation time. The `max_num_spheres` must be positive.
//!
//! The goal of sphere selection is to select spheres such that the entire mesh surface is
//! enclosed by one or more spheres. As an approximation, points are distributed uniformly on the
//! mesh surface and used to test whether the surface is fully enclosed. The `surface_point_density`
//! determines how many test point are distributed. The units for `surface_point_density` are
//! 1 / [mesh-length-unit]^2. For the typical robotics case (with the mesh represented in meters),
//! the default value corresponds to 3 surface points per cm^2. Using higher values for
//! `surface_point_density` will increase the likelihood of full surface enclosure (at the cost of
//! slower generation time). The `surface_point_density` must be positive. Changing the parameter
//! `surface_point_sampling_seed` will result in different surface points being selected and cause
//! different candidate spheres to be selected. This seed may be used, e.g.,  to randomly generate
//! multiple sphere sets with the same `max_overshoot`.
//!
//! The mesh input to `GenerateCollisionSpheres()` is not required to be strictly watertight
//! but is expected to generally represent a volume. For each triangle, the normal is (by default)
//! computed assuming a counter-clockwise winding direction for vertex indices. If the mesh is input
//! with clockwise winding direction for vertex indices, then `flip_normals` should be set to
//! `true` to reverse winding order. The correct surface normal orientation for `triangles` is
//! required for accurately determining whether grid points are interior or exterior to the mesh.
//!
//! Very small and/or degenerate triangles are unlikely to aid in collision sphere generation. Thus,
//! triangles with surface area less than `min_triangle_area` are culled prior to sphere generation
//! and selection. The `min_triangle_area` must be positive.
std::vector<CollisionSphereGenerator::Sphere> GenerateCollisionSpheres(
    const std::vector<Eigen::Vector3d> &vertices,
    const std::vector<Eigen::Vector3i> &triangles,
    double max_overshoot = kCollisionSphereDefaultMaxOvershoot,
    int max_num_spheres = kCollisionSphereDefaultMaxNumSpheres,
    double surface_point_density = kCollisionSphereDefaultSurfacePointDensity,
    int surface_point_sampling_seed = kCollisionSphereDefaultSurfacePointSamplingSeed,
    bool flip_normals = kCollisionSphereDefaultFlipNormals,
    double min_triangle_area = kCollisionSphereDefaultMinTriangleArea);

}  // namespace cumotion
